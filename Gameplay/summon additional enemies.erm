ZVSE2
; Author:   Archer30
; Engine:   ERM 2.0+
; Requires: ERA 3.3+, Era Erm Framework, 77 wog - map rules

; Summon random enemy stacks every X round for battles between human and AI


; ============== SETTINGS ==============
!#VRi^sae_firstRound^:S0;               [First round of the summoning event]
!#VRi^sae_everyXRound^:S1;              [Summoon every X round]
!#VRi^sae_fightValuesEveryHeroLevel^:S10000; [Fight Values of monsters of the AI hero per level]
!#VRi^sae_summonWithoutHero^:S(TRUE);   [Summon with the player's hero level if enemy hero is not available]
; ============ END SETTINGS ============


// Trigger every round from the first round (0) in a battle with both human and AI
!?FU(OnBattleRound)&i^battle_round^>=0/i^battle_hasHuman^/i^battle_humanOnly^<>(TRUE);

; Initialise timer for the first round or plus 1 except the first
!!if&i^battle_round^=0;
  !!VRi^sae_timer^:Si^sae_everyXRound^ -i^sae_firstRound^;
!!el;
  !!VRi^sae_timer^:+1;
!!en;

; Summon additional enemies every X round
!!if&i^sae_timer^=i^sae_everyXRound^;
  !!VRi^sae_timer^:S0;
  !!FU(sae_SummonAdditionalEnemies):P;
!!en;

// Function for summoning AI enemies
!?FU(sae_SummonAdditionalEnemies);
; Check for both sides
!!re i/(BATTLE_LEFT)/(BATTLE_RIGHT);

  !!if&i^battle_ai_%i^;
    !!VR(heroSide:y):Si;

    ; Calculate total fight values for summoning with hero level
    !!if&i^battle_hero_%i^=(NO_HERO);
      ; Get the player's hero 
      !!if&i^sae_summonWithoutHero^;
        !!VR(heroSide):Xi;
      !!el;
        !!FU:E;
      !!en;
    !!en;

    !!HEi^battle_hero_%(heroSide)^:E?(exp:y)/?(lv:y)/1;

    !!VR(totalFv:y):Si^sae_fightValuesEveryHeroLevel^ *(lv);

    ; Get random monster type and quantity, position for summoning
    ; Check if it is eligible to summon (total stack number<20)
    !!FU(sae_CheckIfEligibleToSummon):Pi/?(isEligible:y);

    !!if&(isEligible);
      !!FU(sae_GetRandomMonWithFightValues):P(totalFv)/?(type:y)/?(num:y)/?(isDoubleWide:y);

      !!if&(num)>0;
        !!FU(sae_GetRandomPositionForSummon)&(num)>0:Pi/(isDoubleWide)/?(pos:y);

        !!if&(pos)>-1;
          ; Summon the stack and play sound
          !!SN:P^SUMNELM^;
          !!BU:S(type)/(num)/(pos)/i/-1/(TRUE);
          ; Add in the flag of summoning creature so the stack ID would be released after killed
          !!BU:E(pos)/?(stack:y);
          !!BM(stack):Fd|(MON_FLAG_SUMMONED);
        !!en;
      !!en;
    !!en;
  !!en;
!!en;

!?FU(sae_CheckIfEligibleToSummon);
!#VA(side:x) (isEligible:x);

!!VR(isEligible):S(FALSE);

!!UN:C6919200/4/?(value:y);
!!VR(address:y):S(side) *4 +21692 +(value);
!!UN:C(address)/4/?(stackNum:y);

!!VR(isEligible)&(stackNum)<20:S(TRUE);

!?FU(sae_GetRandomMonWithFightValues);
!#VA(totalFv:x) (type:x) (num:x) (isDoubleWide:x);

; Initialise the number of monsters Return 0 if no monster is found with 100 times of loop
!!VR(num):S0;

; Get the latest monster ID
!!FU(GetMaxMonsterId):P?(lastMon:y);

; Loop through all the monsters
!!re i/0/99;
  !!VR(type):R0/(MON_FIRST)/(lastMon);
  ; Check if the found monster is valid
  !!FU(sae_CheckIfMonValid):P(type)/?(isValid:y);

  ; Check its fight value and see if it is bigger than the total fight values by its own
  !!if&(isValid);
    !!MA:F(type)/?(fv:y);

    ; Break the loop if target is found
    !!br&(fv)<=(totalFv);
  !!en;
!!en;

; Calculate the quantity of the random monster
!!MA:F(MON_PEASANT)/?(fvPeasant:y);     [Ensure the fight value is at least the value of persant to prevent issues]
!!VR(fv):F(fvPeasant)/(INT_MAX);
!!VR(num):S(totalFv) :(fv);
!!MA:X(type)/?(flags:y);
!!VR(isDoubleWide):S(flags) &(MON_FLAG_WIDE);

!?FU(sae_CheckIfMonValid);
!#VA(mon:x) (isValid:x);

!!VR(isValid):S(TRUE);
!!VR(isValid)|(mon)=(MON_NOT_USED_1)/(mon)=(MON_NOT_USED_2)/(mon)=(MON_NOT_USED_3)/(mon)=(MON_NOT_USED_4):S(FALSE);
!!VR(isValid)&(mon)>=(MON_CATAPULT)/(mon)<=(MON_ARROW_TOWERS):S(FALSE);
!!VR(isValid)&(mon)>=(MON_EMISSARY_OF_WAR)/(mon)<=(MON_EMISSARY_OF_LORE):S(FALSE);
!!VR(isValid)&(mon)>=(MON_COMMANDER_FIRST_A)/(mon)<=(MON_COMMANDER_LAST_D):S(FALSE);

!?FU(sae_GetRandomPositionForSummon);
!#VA(side:x) (isDoubleWide:x) (pos:x);

; Initialise position, would be used if no position found
!!VR(pos):S-1;
; Set up array for invalid positions
!!FU(NewIntArray):P22/?(invalidPosArray:y);
!!SN:V(invalidPosArray)/0/0/17/34/51/68/85/102/119/136/153/170/16/33/50/67/84/101/118/136/152/169/186;

!!if&(isDoubleWide);
  !!if&(side)=(BATTLE_LEFT);
    !!FU(Array_Push):P(invalidPosArray)/15/32/49/66/83/100/117/134/151/166/185;
  !!el;
    !!FU(Array_Push):P(invalidPosArray)/1/18/35/52/69/86/103/120/137/154/171;
  !!en;
!!en;

!!SN:M(invalidPosArray)/?(size:y);

; Get a random position and check if it is invalid or occupied, loop for 100 times
!!re i/0/99;
  !!VR(pos):R0/1/185;

  !!re (index:y)/0/(size)/1/-1;
    !!SN:M(invalidPosArray)/(index)/?(invalidPos:y);

    !!br&(invalidPos)=(pos);
  !!en;

  !!if&(index)=(size);
    ; Check if there is a living stack or obstacles on the targeted postion, break the loop if valid
    !!VR(isAvailPos:y):S(TRUE);
    !!BU:E(pos)/?(stack:y) O(pos)/?(flag:y);
    !!VR(isAvailPos)|(stack)>(NO_STACK)/(flag)>0:S(FALSE);

    !!if&(isDoubleWide)/(isAvailPos);
      !!if&(side)=(BATTLE_LEFT);
        !!VR(secPos:y):S(pos) +1;
      !!el;
        !!VR(secPos):S(pos) -1;
      !!en;

      !!BU:E(secPos)/?(secStack:y) O(secPos)/?(secFlag:y);
      !!VR(isAvailPos)|(secStack)>(NO_STACK)/(secFlag)>0:S(FALSE);
    !!el;

    !!br&(isAvailPos);
  !!en;
!!en;
